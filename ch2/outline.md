# Chapter 2

Chapter 2 is longer, but the stuff at the end, while important, is mostly examples with some forshadowing.

## 2.1 Intro to Pairs

#### Exercise 2.4 - Interesting use of closures

Obviously pairs are represented using a faster data structure underneath, but its interesting to see that this advanced data structure can be represented as a closure.

## 2.2 Intro to Lists and Trees

You should really know how to use `map` in section 2.2.1

#### Exercise 2.18 reversing lists

Which one is faster? Iterative or Recursive? Why?


#### Exercise 2.27 deep-reversing lists

#### Exercise 2.31 `tree-map`

### 2.2.3 `map` `filter` `accumulate`

These three functions will practically eliminate the need to write recursive code. Almost all operations on data structures is a combination of these three functions

## 2.3 Symbols

Know about using symbols. It will become important.

2.3.2 - Symbolic Differentiation is really cool

## 2.4 Multiple Representations

Here we apply the same procedure names (such as `real-part`) for complex data represented two ways.

## 2.5 - Generic Operations

This stuff builds off of 2.3 and 2.4 to create a viable package. We'll definitely talk about it.

#### Exercises 2.79 `equ?` and 2.80 `=zero?`

I just did scheme-number and rationals, not complex. Code to run this stuff is in the next chapter so we'll hold off on actually testing.